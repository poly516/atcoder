abc103 D - Islands War
https://abc103.contest.atcoder.jp/tasks/abc103_d
-----------------------------------------------------------------------------------------------------------------------------------------
题目意思:
有n个城市，从左往右按1-n编号，并从东往西排列。
1和2，2和3......n-1和n之间都有一座桥，也就是说有n-1座桥。
现在给你m组数，希望你能拆除尽可能少的桥，
使给你的m行数l和r两座城市不相连。
输出你所需要拆除的桥最少一共有几个。
-----------------------------------------------------------------------------------------------------------------------------------------
解题思路:
由于它所给的每一组数都是无序的，
所以在做之前最为重要的是要先排序。
然后，一个一个往后加。
当到达第一个的r时，停止。
这时，便需要用贪心。
如果后面一个的l不超过，便往后。
但是要注意，r如果比一开始的小的话要替换。
算完一遍后便是拆了一座桥。
-----------------------------------------------------------------------------------------------------------------------------------------
伪代码:
sort(v.begin(),v.end());
for (int i=0;i<m&&num<=n;)
  //num是指桥的位置
	if (num<v[i].second)
		num++;//达到可行的最右边，一定是最好的，这便是贪心的原则
	else if (num==v[i].second){
		ans++;
		while (i<m&&num>=v[i].first){
			if (num>v[i].second) num=v[i].second;//桥必须向左移动
			i++;
		}
	}
-----------------------------------------------------------------------------------------------------------------------------------------
错误原因:
一开始以为是自己的sort太慢了，
但是，由于快速排序实际所用速度是：O(n*log(n)).
所以n最大的时候，也就是n=100000时O(n*log(n))=O(500000);
 也就是说不可能爆的，就说是循环里超了
bool f(pair<int,int> a,pair<int,int> b){
	return a.first<b.first;
}
int main(){
	//输入，预处理
	sort(v.begin(),v.end(),f);
	int d=v[0].second;
	for (int i=1;i<m;i++)
		if (d>v[i].first){
      //拆前面d位置的桥可以使它的l与r分开，舍去
			if (d>v[i].second) d=v[i].second;//桥必须向左移动
			v.erase(v.begin()+i);//删除
			m-=1;
			i--;
		}
		else
			d=v[i].second;
  //输出
	return 0;
}
