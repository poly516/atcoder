# atcoder
wall
我一开始用dfs遍历每一种可能。这样是可行，但会超时。所以，可以通过dfs的剪枝来做。
因为目标是变成1，所以由这个数变向其他的数时，大小不可以超过（这个数，1）所需值。
魔法值和也不可以超过（这个数，1）的值。
不过，要把遍历过的数先标记，以免出现死循环的状况。

Sequence
一眼便可以看出，数据必须是一正一负的。
我们知道，把和尽量控制在1和-1，是最合理的（或者不变）。
但是，我们不知道是一正一负好还是一负一正好。
所以，可以进行两次循环，比较一下那一个小就可以了。
